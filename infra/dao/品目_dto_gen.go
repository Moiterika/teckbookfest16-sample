// Code generated by xlsx2go.go; DO NOT EDIT.

package dao

import (
	"encoding/json"
	types "techbookfest16-sample/domain/types"
)

type Dto品目 struct {
	FldID        Id           `json:"ID"`
	Fldコード       types.Code品目 `json:"コード"`
	Fld名称        string       `json:"名称"`
	Fld基準単位ID    Id           `json:"基準単位ID"`
	Fld生産用品目区分ID Id           `json:"生産用品目区分ID"`

	rowState DataRowState
	Ub       *ub品目 `json:"-"`
}

func (d Dto品目) TableName() string {
	return "品目"
}
func (d Dto品目) RowState() DataRowState {
	return d.rowState
}

// Import はDto品目型に主キー以外を上書きする。
func (d *Dto品目) Import(コード types.Code品目, 名称 string, 基準単位ID Id, 生産用品目区分ID Id) {
	// 項目がすべて一致していたら、何もしない
	if d.Fldコード == コード && d.Fld名称 == 名称 && d.Fld基準単位ID == 基準単位ID && d.Fld生産用品目区分ID == 生産用品目区分ID {
		return
	}
	if d.Fldコード != コード {
		d.Fldコード = コード
		d.Ub.Set(Tbl品目().Fldコード(), コード)
	}
	if d.Fld名称 != 名称 {
		d.Fld名称 = 名称
		d.Ub.Set(Tbl品目().Fld名称(), 名称)
	}
	if d.Fld基準単位ID != 基準単位ID {
		d.Fld基準単位ID = 基準単位ID
		d.Ub.Set(Tbl品目().Fld基準単位ID(), 基準単位ID)
	}
	if d.Fld生産用品目区分ID != 生産用品目区分ID {
		d.Fld生産用品目区分ID = 生産用品目区分ID
		d.Ub.Set(Tbl品目().Fld生産用品目区分ID(), 生産用品目区分ID)
	}

}

// jsonKey品目 はロギング用jsonのキー。主キー項目
type jsonKey品目 struct {
	FldID Id `json:"ID"`
}

// jsonKey はロギング用jsonのキーを生成するメソッド。
func (d *Dto品目) jsonKey() jsonKey品目 {
	return jsonKey品目{FldID: d.FldID}
}

type json品目 struct {
	RowState string    `json:"row_state"`
	K        jsonKey品目 `json:"k"`
	V        *Dto品目    `json:"v,omitempty"`
}

// ToJson はMarshalJSONと同じ機能を提供するメソッド。しかし、無限ループを防ぐため、別名メソッドにしてある。
func (d *Dto品目) ToJson() ([]byte, error) {
	switch d.rowState {
	case Modified:
		j := make(map[string]interface{})
		j["row_state"] = d.rowState.String()
		j["k"] = map[string]interface{}{"ID": d.FldID}
		j["v"] = d.Ub.copyMap()
		return json.Marshal(j)
	case Deleted:
		return json.Marshal(json品目{
			K:        d.jsonKey(),
			RowState: d.rowState.String(),
			V:        nil,
		})
	default:
		return json.Marshal(json品目{
			K:        d.jsonKey(),
			RowState: d.rowState.String(),
			V:        d,
		})
	}
}
