// Code generated by xlsx2go.go; DO NOT EDIT.

package dao

import (
	"database/sql"
	"fmt"
	xerrors "golang.org/x/xerrors"
	"strconv"
	types "techbookfest16-sample/domain/types"
)

type daoDbEnum受払区分 struct {
	dm        *DaoDbManager
	db        *sql.DB
	WbForInit WbEnum受払区分
}

func (d *daoDbEnum受払区分) init() (err error) {
	d.dm.dtEnum受払区分, err = d.SelectW(d.WbForInit)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	return
}
func (d *daoDbEnum受払区分) Reset() {
	list := make([]*DtoEnum受払区分, 0, len(d.dm.dtEnum受払区分))
	for _, dr := range d.dm.dtEnum受払区分 {
		if dr.rowState == Deleted {
			dr.rowState = Detached
			continue
		} else {
			dr.rowState = UnChanged
			list = append(list, dr)
		}
	}
	d.dm.dtEnum受払区分 = list
}
func (d daoDbEnum受払区分) Dt() ([]*DtoEnum受払区分, error) {
	if len(d.dm.dtEnum受払区分) == 0 {
		err := d.init()
		if err != nil {
			err = xerrors.Errorf(": %w", err)
			return nil, err
		}
	}
	return d.dm.dtEnum受払区分, nil
}
func (d daoDbEnum受払区分) SelectAll() ([]*DtoEnum受払区分, error) {
	sql := fmt.Sprintf(sqlSelectEnum受払区分, "")
	rows, err := d.db.Query(sql)
	if err != nil {
		return nil, xerrors.Errorf("sql=%s: %w", sql, err)
	}
	defer rows.Close()
	var dt []*DtoEnum受払区分
	for rows.Next() {
		var dr DtoEnum受払区分
		err = rows.Scan(&dr.Fld受払区分, &dr.Fld名称, &dr.Fld受入フラグ, &dr.Fld符号)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		dr.rowState = Detached
		dr.Ub = NewUbEnum受払区分()
		dt = append(dt, &dr)
	}
	return dt, rows.Err()
}
func (d daoDbEnum受払区分) SelectW(wb WbEnum受払区分) ([]*DtoEnum受払区分, error) {
	where := wb.build()
	prms, exists := where.Params()
	if exists {
		sql := fmt.Sprintf(sqlSelectEnum受払区分, where.String())
		rows, err := d.db.Query(sql, prms...)
		if err != nil {
			return nil, xerrors.Errorf("sql=%s, args=%v: %w", sql, prms, err)
		}
		defer rows.Close()
		var dt []*DtoEnum受払区分
		for rows.Next() {
			var dr DtoEnum受払区分
			err = rows.Scan(&dr.Fld受払区分, &dr.Fld名称, &dr.Fld受入フラグ, &dr.Fld符号)
			if err != nil {
				return nil, xerrors.Errorf(": %w", err)
			}
			dr.rowState = Detached
			dr.Ub = NewUbEnum受払区分()
			dt = append(dt, &dr)
		}
		return dt, rows.Err()
	} else {
		return d.SelectAll()
	}
}
func (d daoDbEnum受払区分) Count() (cnt int64, err error) {
	return d.CountW(NewWbEnum受払区分())
}
func (d daoDbEnum受払区分) CountW(wb WbEnum受払区分) (cnt int64, err error) {
	where := wb.build()
	prms, exists := where.Params()
	if exists {
		err = d.db.QueryRow(fmt.Sprintf(sqlSelectEnum受払区分ForAggregation, "count(\"受払区分\")", where.String()), prms...).Scan(&cnt)
		if err != nil {
			err = xerrors.Errorf(": %w", err)
			return
		}
		return
	} else {
		err = d.db.QueryRow(fmt.Sprintf(sqlSelectEnum受払区分ForAggregation, "count(\"受払区分\")", "")).Scan(&cnt)
		if err != nil {
			err = xerrors.Errorf(": %w", err)
			return
		}
		return
	}
}

// Min はEnum受払区分のfld最小値を返します。
func (d daoDbEnum受払区分) Min(fld fldEnum受払区分) (min int64, err error) {
	return d.MinW(fld, NewWbEnum受払区分())
}
func (d daoDbEnum受払区分) MinW(fld fldEnum受払区分, wb WbEnum受払区分) (min int64, err error) {
	where := wb.build()
	prms, exists := where.Params()
	var x sql.NullInt64
	if exists {
		err = d.db.QueryRow(fmt.Sprintf(sqlSelectEnum受払区分ForAggregation, fmt.Sprintf("min(%s)", strconv.Quote(string(fld))), where.String()), prms...).Scan(&x)
	} else {
		err = d.db.QueryRow(fmt.Sprintf(sqlSelectEnum受払区分ForAggregation, fmt.Sprintf("min(%s)", strconv.Quote(string(fld))), where.String())).Scan(&x)
	}
	if err != nil {
		err = xerrors.Errorf(": %w", err)
		return
	}
	if !x.Valid {
		err = xerrors.Errorf(": %w", types.ErrNotFound)
		return
	}
	min = x.Int64
	return
}

// Max はEnum受払区分のfld最大値を返します。
func (d daoDbEnum受払区分) Max(fld fldEnum受払区分) (max int64, err error) {
	return d.MaxW(fld, NewWbEnum受払区分())
}
func (d daoDbEnum受払区分) MaxW(fld fldEnum受払区分, wb WbEnum受払区分) (max int64, err error) {
	where := wb.build()
	prms, exists := where.Params()
	var x sql.NullInt64
	if exists {
		err = d.db.QueryRow(fmt.Sprintf(sqlSelectEnum受払区分ForAggregation, fmt.Sprintf("max(%s)", strconv.Quote(string(fld))), where.String()), prms...).Scan(&x)
	} else {
		err = d.db.QueryRow(fmt.Sprintf(sqlSelectEnum受払区分ForAggregation, fmt.Sprintf("max(%s)", strconv.Quote(string(fld))), where.String())).Scan(&x)
	}
	if err != nil {
		err = xerrors.Errorf(": %w", err)
		return
	}
	if !x.Valid {
		err = xerrors.Errorf(": %w", types.ErrNotFound)
		return
	}
	max = x.Int64
	return
}
